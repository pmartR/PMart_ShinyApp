---
title: "Peptide Data Template"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, error = FALSE)
library(dplyr); library(pmartR); library(knitr); library(DT); library(ggplot2);
library(data.table); library(patchwork); library(purrr)

# This data will be passed to the markdown through shiny
rootdir <- "/Users/degn400/Desktop/Git_Repos/pmart_standalone/Markdowns"
pepData <- readRDS(file.path(rootdir, "pepData_normalize.RDS"))
pmart_inputs <- readRDS(file.path(rootdir, "pmart_inputs_normalize.RDS"))

#########################
## UNIVERSAL FUNCTIONS ##
#########################

# Get whether a filter was applied or not
getAppliedFilter <- function(filterName) {
  ifelse(pmart_inputs[[filterName]][1] == 1, "Yes", "No")
}

# Extract data from the rdb files within a package 
extract_help <- function(pkg, fn = NULL) {
  rdbfile <- file.path(find.package(pkg), "help", pkg)
  rdb <- tools:::fetchRdDB(rdbfile, key = fn)
  
  f <- function(x) capture.output(tools::Rd2HTML(x))
  if(is.null(fn)) lapply(rdb, f) else f(rdb)
}
```

## Upload Data 

### *Expression Data*

An **`r ifelse(pmart_inputs$labeled_yn, "labelled", "unlabelled")`** peptide expression 
data file called **"`r pmart_inputs$file_edata$name`"** was uploaded to pmart. The column 
that designates unique molecules was marked as **"`r pmart_inputs$id_col`"**. The original
scale of the data was **`r ifelse(pmart_inputs$data_scale == "abundance", "raw intensity", pmart_inputs$data_scale)`**
`r ifelse(pmart_inputs$transform == "Select one", ".", paste0("and was transformed to <B>", ifelse(pmart_inputs$transform == "abundance", "raw intensity", pmart_inputs$transform), "</B>"))`. 
The value to denote missing data was **"`r pmart_inputs$na_symbol`"** and the expression data
**`r ifelse(pmart_inputs$normalized_yn == "0", "was not", "was")`** normalized. 

```{r Upload Data: Expression Data}
plot(pepData, bw_theme = TRUE)
```

### *Biomolecule Information*

An associated biomolecule information file was also uploaded called 
**"`r pmart_inputs$file_emeta$name`"** and the protein identifier column was
designated as **"`r pmart_inputs$protein_column`"**.

## Group Samples

### *Sample Information*

An associated sample information file was also uploaded called 
**"`r pmart_inputs$file_fdata$name`"**. This metadata file 
**`r ifelse(pmart_inputs$proteins_yn == "FALSE", "does not", "does")`**
contain peptide to protein mappings. Trimmed sample names
**`r ifelse(pmart_inputs$usevizsampnames == "No", "were not", "were")`** used. The 
column in the sample information file which indicates sample names was 
designated as **"`r pmart_inputs$fdata_id_col`"**.

### *Grouping Information*

```{r Grouping Information: Main Effects and Covariates}
resetNULL <- function(x) {ifelse(is.null(x), "None", x)}

data.table("Effect or Covariate" = c("First Main Effect", "Second Main Effect",
  "First Covariate", "Second Covariate"), "Set Value" = c(resetNULL(pmart_inputs$gcol1),
  resetNULL(pmart_inputs$gcol2), resetNULL(pmart_inputs$cvcol1), 
  resetNULL(pmart_inputs$cvcol2))) %>% kable()
```

This table summarizes all the user specified main effects or covariates in pmart. The "Set Value"
column denotes the name of the column in the "Sample Information" file assigned as a main
effect or covariate. 

### *Number of Samples per Main Effects*

```{r Grouping Information: Bar Chart, fig.height = 10}
# Generate plots for main effects 
plotForMainEffects <- function(effect) {
  count <- pepData$f_data %>%
    select(all_of(effect)) %>%
    table() %>%
    as.data.table() 
  colnames(count) <- c("Group", "Number of samples")
  ggplot(count, aes(x = Group, y = `Number of samples`, fill = Group)) +
    geom_bar(stat = "identity") + theme_bw() + 
    geom_text(aes(label = `Number of samples`), 
              position = position_dodge(width = 1), vjust = -0.25)
}

if (is.null(pmart_inputs$gcol1) == FALSE && pmart_inputs$gcol1 != "None") {
  (plot(pepData, bw_theme = TRUE, order_by = pmart_inputs$gcol1, color_by = 
       pmart_inputs$gcol1)) /
  (plotForMainEffects(pmart_inputs$gcol1) + 
    ggtitle(paste("First Main Effect:", pmart_inputs$gcol1))) 
}
if (is.null(pmart_inputs$gcol2) == FALSE && pmart_inputs$gcol2 != "None") {
  (plot(pepData, bw_theme = TRUE, order_by = pmart_inputs$gcol2, color_by = 
       pmart_inputs$gcol2)) /
  (plotForMainEffects(pmart_inputs$gcol2) + 
    ggtitle(paste("Second Main Effect:", pmart_inputs$gcol2))) 
}
```

## Data Summary

### *Summary Table*

```{r Data Summary: Main Table}
pepDataSum <- data.frame("Data" = summary(pepData))
pepDataSum %>% kable()
```

The first column denotes a property of the peptide data, and the "Data" column
reveals that properties' value.

### *Missing Value Table*

```{r Data Summary: Missing Value Table}
pepData$e_data %>%
  select(-pmart_inputs$id_col) %>%
  map(~sum(is.na(.))) %>%
  data.frame() %>%
  t() %>%
  data.frame() %>%
  setNames("Missing Observations") %>%
  mutate(
    "Proportion Missing" = round(`Missing Observations` / nrow(pepData$e_data), 3),
  ) %>% kable()
```

The first column denotes the sample and the second is the missing number of observations.
The third column represents the second as a percentage of the total number of observations
for that sample. 

## Filter

```{r Filter: List Filters}
# List the filter names to check
filters <- c("add_molfilt", "add_cvfilt", "add_imdanovafilt", "add_profilt",
  "add_rmdfilt", "add_customfilt")
```

Filters **`r ifelse("Yes" %in% lapply(filters, getAppliedFilter) %>% unlist() %>% unique(), "were", "were not")`**
applied. 

### *Summary of Applied Filters*

```{r Filter: Table Summarizing Applied Filters}
# List a table of filters 
FilterTable <- data.table(
  "Filter" = c("Molecule Filter", "CV Filter", "imd-ANOVA Filter", 
               "Proteomics Filter", "rMD Filter", "Custom Filter"),
  "Type" = c(rep("Biomolecule", 4), rep("Sample", 2)),
  "Applied" = lapply(filters, getAppliedFilter) %>% unlist(),
  "Parameters" = c(
    paste0("Molecule Number Min: ", pmart_inputs$mol_min_num),
    paste0("Max CV: ", pmart_inputs$cv_threshold),
    paste0("ANOVA Min: ", pmart_inputs$min_nonmiss_anova, " & ",
           "G-test Min: ", pmart_inputs$min_nonmiss_gtest),
    paste0("Peptide Number Min: ", pmart_inputs$min_num_peps, " & ",
           "Remove Degenerates: ", ifelse(pmart_inputs$degen_peps, "Yes", "No")),
    paste0("P-Value Threshold: ", pmart_inputs$pvalue_threshold, " & ",
           "Outlier Metrics: ", pmart_inputs$rmd_metrics %>% paste(collapse = ", ")),
    paste0("Samples with ", paste(c(pmart_inputs$fdata_customfilt_choices, 
           pmart_inputs$fdata_customfilt_regex), collapse = " "), "were ",
           ifelse(pmart_inputs$remove_or_keep == "Remove", "removed.", "kept."))
  )
)

FilterTable <- FilterTable[FilterTable$Applied == "Yes",]
FilterTable %>% kable()
```

### *Molecule Filter*

```{r Filter: Molecule Filter}
if ("Molecule Filter" %in% FilterTable$Filter) {
  
  # Set up what the molecular filter was (either an attr or build from raw data)
  mole_filt <- molecule_filter(pepData) 
  
  # Set the number of observations
  min_num_observations <- pmart_inputs$mol_min_num %>% as.numeric()
  
  # Get the original count 
  originalCount_mole <- pepData$e_data %>% nrow()
  
  # Apply filter
  pepData <- applyFilt(mole_filt, pepData, min_num = min_num_observations)
    
  # Get the filtered count 
  filteredCount_mole <- pepData$e_data %>% nrow()
  
  # Write text
  MoleculeFilterText <- paste("This means that", originalCount_mole - filteredCount_mole, 
    "biomolecules were filtered at a minimum of", min_num_observations, 
    "observations of a unique biomolecule per sample.")
  
}
```

A molecule filter **`r ifelse("Molecule Filter" %in% FilterTable$Filter, "was", "was not")`**
applied. `r ifelse("Molecule Filter" %in% FilterTable$Filter, MoleculeFilterText, "")`

```{r Filter: Molecule Filter Table and Plot}
if ("Molecule Filter" %in% FilterTable$Filter) {
  plot(mole_filt, min_num = min_num_observations, bw_theme = TRUE) + 
    xlim(c(0, min_num_observations + 3))
}
if ("Molecule Filter" %in% FilterTable$Filter) {
  data.table("Count Before Filter" = originalCount_mole, 
               "Number Filtered" = originalCount_mole - filteredCount_mole,
               "Remaining" = filteredCount_mole) %>% kable()
}
```

### *CV Filter*

```{r Filter: CV Filter}
if ("CV Filter" %in% FilterTable$Filter) {
  
  # Set up what the molecular filter was (either an attr or build from raw data)
  cv_filt <- cv_filter(pepData) 
  
  # Set the number of observations
  cv_thresh <- pmart_inputs$cv_threshold
  
  # Get the original count 
  originalCount_cv <- pepData$e_data %>% nrow()
  
  # Apply filter
  pepData <- applyFilt(cv_filt, pepData, cv_threshold = cv_thresh)
    
  # Get the filtered count 
  filteredCount_cv <- pepData$e_data %>% nrow()
  
  # Write text
  MoleculeFilterText <- paste("This means that", originalCount_cv - filteredCount_cv, 
    "biomolecules were filtered, since their coefficient of variation was greater than", 
    paste0(cv_thresh, "."), extract_help("pmartR", "cv_filter")[35] %>% gsub(pattern = "<p>", replacement = "", fixed = T))
  
}
```

A CV filter **`r ifelse("CV Filter" %in% FilterTable$Filter, "was", "was not")`**
applied. `r ifelse("CV Filter" %in% FilterTable$Filter, MoleculeFilterText, "")`

```{r Filter: CV Filter Table and Plot}
if ("CV Filter" %in% FilterTable$Filter) {
  plot(cv_filt, cv_threshold = cv_thresh, bw_theme = TRUE) + 
    xlim(c(0, cv_thresh + 25))
}
if ("CV Filter" %in% FilterTable$Filter) {
  data.table("Count Before Filter" = originalCount_cv, 
               "Number Filtered" = originalCount_cv - filteredCount_cv,
               "Remaining" = filteredCount_cv) %>% kable()
}
```

## Normalization

### *Manual*

Manual normalization **`r ifelse(pmart_inputs$spans_or_manual == "manual", "was", "was not")`**
used to normalize the data. 

### *SPANS*

SPANS normalization **`r ifelse(pmart_inputs$spans_or_manual == "spans", "was", "was not")`**
used to normalize the data.







